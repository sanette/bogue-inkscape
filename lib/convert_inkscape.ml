(* This file is part of Bogue-inkscape

   Copyright Vu Ngoc San 2024

   This module converts the "Inkscape" type generated by Parse_inkscape into a
   simplified Bogue type.
*)

module I = Parse_inkscape
module SSet = Set.Make(String)

(* We introduce simplified Bogue types *)

type rect = { x : int; y : int; w : int; h : int }
type style = {
  fill : I.color option;
  stroke_width : int option;
  stroke_color : I.color option;
  radius : int option}

type widget_content =
  | Box of rect
  | Button of (rect * string) (* à compléter? *)
  | Image of (rect * string)
type widget = { id : string; content : widget_content }

type layout_content =
  | Resident of widget
  | Rooms of layout list
and layout = {
  id : string;
  name : string option;
  rect : rect;
  content : layout_content;
  style : style }

let rec map_resident f l =
  match l.content with
  | Resident w -> f l w
  | Rooms rs -> let rs = List.map (map_resident f) rs in
    { l with content = Rooms rs }

let rec map_layout f l =
  match l.content with
  | Resident _ -> f l
  | Rooms rs ->
    let ll = f l in
    let rs = List.map (map_layout f) rs in
    { ll with content = Rooms rs }

let round x = int_of_float (Float.round x)

let scalex canvas x =
  round (x *. canvas.I.xscale)

let scaley canvas y =
  round (y *. canvas.I.yscale)

(* I.rect to rect *)
let rect canvas r =
  let x, y, w, h =
    scalex canvas r.I.x, scaley canvas r.I.y,
    scalex canvas r.I.w, scaley canvas r.I.h in
  { x; y; w; h }

let scaley_opt canvas t =
  Option.map (scaley canvas) t

let style canvas s =
  let fill = s.I.fill in
  let stroke_color = s.I.stroke_color in
  let stroke_width = scaley_opt canvas s.I.stroke_width in
  (* : TODO use x scale for too? *)
  let radius = scaley_opt canvas s.I.radius in
  { fill; stroke_width; stroke_color; radius }

(* TODO gérer le cas où le nouveau id existe déjà... *)
let id pool r =
  let id = r.I.id in
  if SSet.mem id !pool
  then print_endline "Error: id [%s] is not unique";
  pool := SSet.add id !pool;
  id

let widget_of_rect pool canvas r : widget =
  let id = id pool r in
  let content =
    match r.I.label with
    | Some "#Button" ->
      let label = Option.value ~default:"" r.I.desc in
      Button (rect canvas r, label)
    | _ -> Box (rect canvas r) in
  { id; content }

let get_rect (wd : widget) =
  match wd.content with
  | Box r -> r
  | Button (r, _) -> r
  | Image (r, _) -> r

let resident name style (wg : widget) : layout =
  let id = "" (* wg.id ^ "_l" *) in (* To be determined later *)
  let rect = get_rect wg in
  let content = Resident wg in
  { id; name; rect; content; style }

let widget_of_image pool canvas r href =
  let id = id pool r in
  let content = Image (rect canvas r, href) in
  { id; content }

let button_of_group _name _pool _canvas _olist =
  failwith "Not_implemented"

let rec layout_of_group name pool canvas (r, olist) =
  let id = id pool r in
  let rect = rect canvas r in
  let style = style canvas r.I.style in
  let content = Rooms (List.map (layout_of_obj pool canvas) olist) in
  { id; name; rect; content; style }

and layout_of_obj pool canvas = function
  | I.Rect r -> widget_of_rect pool canvas r
                |> resident r.I.title (style canvas r.I.style)
  | I.Image (r, href) -> widget_of_image pool canvas r href
                         |> resident r.I.title (style canvas r.I.style)
  | I.Group (r, olist, []) -> begin
      match r.I.label with
      | Some "#Button" -> button_of_group r.I.title pool canvas olist
      | _ -> layout_of_group r.I.title pool canvas (r, olist)
    end
  | I.Group _ -> failwith "tlist should be empty here"

let layout_of_svg (canvas, olist) =
  let r = canvas.I.viewport in
  let pool = ref SSet.empty in
  let l = layout_of_group r.I.title pool canvas (r, olist) in

  (* Now we replace inkscape ids by ocaml ids *)
  let table, new_pool = Sanitize.sanitize_set !pool in
  Sanitize.print_table table;
  let suffix = match Sanitize.valid_suffix "_l" new_pool with
    | Ok s -> s
    | Error (s,msg) -> print_endline msg; s in
  let layout =
    l |> map_layout (fun (ll : layout) ->
        let id = if ll.id = "" then "" else Hashtbl.find table ll.id in
        { ll with id })
    |> map_resident (fun ll w ->
        assert (ll.id = "");
        let id = Hashtbl.find table w.id in
        let w = { w with id } in
        let id_l = id ^ suffix in
        Hashtbl.add table id_l id_l;
        { ll with id = id_l; content = Resident w })  in
  table, layout

let layout_of_ink = function
  | I.Svg s -> layout_of_svg  s
  | _ -> failwith "Not a valid Inkscape data"

(* if s = "#abcd" we look for the key "abcd" in the table *)
let find_hashtag table s =
  if s <> "" && s.[0] = '#'
  then Hashtbl.find table (String.sub s 1 (String.length s - 1))
  else s

let update_connection_id table c =
  let open I in
  let dst = find_hashtag table c.dst in
  let src = find_hashtag table c.src in
  { c with src; dst }

let update_connections_ids table cs =
  List.map (update_connection_id table) cs

let convert svg c =
  let table, layout = layout_of_svg svg in
  let c = update_connections_ids table c in
  layout, c

(*

dune utop

Sys.chdir "/home/san/prog/ocaml/bogue-inkscape";;
let svg, c = Bogue_inkscape__Parse_inkscape.parse "bogue-inkscape.svg";;
let table, layout = Bogue_inkscape.layout_of_svg svg;;
update_connections_ids table c

*)
